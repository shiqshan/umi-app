<!DOCTYPE html>
<html lang='en'>
<head>
    <meta charset='UTF-8'>
    <title>js练习</title>
</head>
<body>

</body>
<script>
    /**
     * javaScript 中如何对一个对象进行深度 clone? (不采用将对象转成json字符串的方法)
     */
    function deepClone(obj) {
        //function  array, object other
        if (obj instanceof Function) {
            return obj;
        } else if (obj instanceof Array) {
            let arr = [];
            for (let i = 0; i < obj.length; i++) {
                arr[i] = deepClone(obj[i]);
            }
        } else if (obj instanceof Object) {
            let newObj = {};
            for (const objKey in obj) {
                newObj[objKey] = deepClone(obj[objKey]);
                return newObj;
            }
        } else {
            return obj;
        }
    }

    /**
     * 请将连字命名格式的字符串转成驼峰式。比如将 foo="get-element-by-id"转化成驼峰表示的结果是"getElementByld”。
     * @constructor
     */
    function change(value) {
        const arr = value.split('-'); //['get', 'element', 'by', 'id']
        for (let i = 1; i < arr.length; i++) {
            if (i != 0) {
                arr[i] = arr[i].slice(0, 1).toUpperCase() + arr[i].slice(1);
            }
        }
        return arr.join('');
    }

    /**
     * 数组扁平化, 嵌套的数组，平铺一层  [1,2,[3,4,5]] => [1,2,3,4,5]
     */
    function flattenArray(value) {
        //不是数组直接返回
        if (!Array.isArray(value)) return;
        let result = [];
        for (let i = 0; i < value.length; i++) {
            //如果子项是数组，递归
            if (Array.isArray(value[i])) {
                result = result.concat(flattenArray(value[i]));
            } else {
                result = result.concat(value[i]);
            }
        }
        return result;
    }

    /**
     * 实现数组去重, indexof去重, set去重
     */
    function uniqueArray(value) {
        if (!Array.isArray(value)) return;
        const arr = [];
        value.forEach(item => {
            //没找到，push 到 arr
            if (arr.indexOf(item) === -1) {
                arr.push(item);
            }
        });
        return arr;
    }

    function uniqueArrayBySet(value) {
        if (!Array.isArray(value)) return;
        return [...new Set(value)];
    }

    /**
     * 设计一个简单的任务队列，要求分别在 1,3,4 秒后打印出 “1”, “2”, “3”
     */
    class Queue {
        constructor() {
            this.queue = [];
            this.time = 0;
        }

        addEvent(fn, time) {
            this.queue.push({ callback: fn, ms: time });
            return this;
        }

        start() {
            this.queue.forEach(item => {
                setTimeout(item.callback, item.ms);
            });
        }
    }

    const mq = new Queue();
    mq.addEvent(() => console.log('1'), 1000);
    mq.addEvent(() => console.log('2'), 3000);
    mq.addEvent(() => console.log('3'), 5000);

    // mq.start();

    function A() {
        this.name = '111';
        this.age = 22;
        this.sex = '1';
    }

    function B() {
        this.kkk = '111';
        this.vvv = 22;
        this.ggg = '1';
    }

    //A extends B
    A.prototype = new B();
    const a = new A();

    // forin 会遍历继承属性。
    for (const key in a) {
        if (Object.hasOwn(a, key)) {
            // console.log(key);
        }
    }

    /**
     * 数组的map和forEach迭代有什么区别？哪个遍历更快？为什么更快？这两种迭代能不能中断？
     */
    //map 快， 都不能中断， 只能通过 抛异常终止
    try {
        [1, 2, 3, 4, 5].forEach(item => {
            // console.log(item);
            if (item == 3) {
                throw Error;
            }
        });
    } catch (e) {
    }

    /**
     * 冒泡排序
     */
    const arr = [4, 3, 8, 1, 45, 32, 0, 7, 34];
    for (let i = 0; i < arr.length; i++) {
        for (let j = 0; j < arr.length - i; j++) {
            let temp;
            if (arr[j] > arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }

    /**
     * 手写防抖和节流
     */
    function fangdou(fn, ms) {
        let timer = null;
        return function(...args) {
            clearTimeout(timer);
            timer = setTimeout(() => {
                fn.apply(this, args);
            }, ms);
        };
    }

    function jieliu(fn, ms) {
        let pre = Date.now();
        return function(...args) {
            const now = Date.now();
            if (pre - time >= ms) {
                fn.apply(this, args);
                pre = now;
            }
        };
    }

    /**
     * 数组urls，如何同步请求。（数组长度确定/数组长度不确定）
     */
    async function doFetch(list) {
        for (let i = 0; i < list.length; i++) {
            await new Promise(resolve => {
                setTimeout(() => {
                    resolve();
                }, 1000);
            });
            // console.log(i);
        }
    }

    const urls = ['1', '2', '3'];
    doFetch(urls);

</script>
</html>